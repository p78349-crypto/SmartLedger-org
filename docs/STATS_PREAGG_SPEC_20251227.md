# 통계 월단위 사전집계(Pre-Aggregation) 설계서 (2025-12-27)

## 목적 (TODO 2~4)
- **TODO 2**: 통계에 사용될 여러 “메모 소스”를 1달 단위로 미리 집계해 DB(또는 영속 저장소)에 저장하고, 통계 화면은 집계값을 불러와 사용한다.
- **TODO 3**: 월단위 집계를 **숫자 중심**으로 저장할 때, 연간 저장량을 가늠하고 과도한 저장을 피한다.
- **TODO 4**: 통계는 숫자로 그래프/텍스트를 출력하므로, “메모(텍스트)”를 **통계용 숫자(카운트/합계)**로 변환·축약하여 저장한다.

> 범위: 이 문서는 “숫자 중심” 월단위 집계 설계를 우선한다.
> (메모 텍스트별 TOP-N을 정확히 유지하는 히스토그램 저장은 별도 확장으로 분리)

---

## 현재 코드 기반 전제(관찰)
- 거래 로딩은 앱 실행 세션 내 1회 로드 후 캐시된다: `TransactionService.loadTransactions()`는 `_initialized` 이후 재로딩하지 않는다.
- 입력 통계(최근 6개월)는 화면에서 정렬/필터 후 스캔한다: `lib/screens/input_stats_screen.dart`에서 최근 183일 + 최대 1500건 제한.

즉, 체감 병목은 “매번 디스크 로딩”보다 **화면 진입 시 스캔/정렬/집계**에 가깝고,
앱 재실행 시에는 SharedPreferences의 큰 JSON 디코딩이 병목이 될 수 있다.

---

## 용어 정의
- **Memo Source(메모 소스)**: 통계에 포함하려는 데이터 발생원
  - 예: 거래추가 메모, 간편지출(1줄), 장바구니/일괄입력 메모, 수입 메모, 자산 메모, ROOT 메모 등
- **Memo Event**: 서로 다른 소스의 데이터를 통계용으로 통일한 최소 이벤트
- **YearMonth**: `YYYY-MM` 형태의 월 버킷 키

---

## 핵심 전략
### 1) 모든 소스를 “Memo Event”로 통합
메모가 어디서 발생했든, 통계는 아래 공통 형태로 수집/집계한다.

**MemoEvent(개념 모델)**
- `accountName: String` (ROOT 포함 여부는 정책으로 결정)
- `sourceType: String` (예: `tx_memo`, `quick_input`, `cart_memo`, `asset_memo`, `root_memo` …)
- `yearMonth: String` (`YYYY-MM`)
- `count: int` (기본 1)
- `amountAbs: double?` (있는 경우만. 없으면 null)
- `category: String?` (있는 경우만)

> 중요: 이 설계의 1차 목표는 “텍스트를 보관하지 않고 숫자로 축약”이다.


### 2) 월별 사전집계 테이블(또는 키/값 캐시)을 만든다
집계는 최소한 아래 2종을 권장한다.

- **월·소스별 요약(Summary)**
  - `countTotal` (이벤트 건수)
  - `amountTotalAbs` (금액 합계가 있는 이벤트만 절대값 합)

- (선택) **월·소스·카테고리별 요약(Category Summary)**
  - 카테고리 그래프가 필요할 때만 적용


### 3) 갱신(Invalidate/Rebuild) 정책은 “월 단위 재빌드”로 시작
정확성과 구현 안정성을 위해 1차는 증분 업데이트보다 **해당 월만 재집계(덮어쓰기)**를 우선한다.

- 트리거: 거래/입력 데이터 추가·수정·삭제
- 영향 범위: 변경된 데이터의 `yearMonth`(그리고 “최근 6개월 범위”)
- 동작:
  1) 해당 월의 원본 이벤트를 다시 스캔
  2) 월 집계를 재계산
  3) 저장소에 덮어쓰기

---

## 저장소 선택 (현실적 단계)
### 단계 1: SharedPreferences 기반(가벼운 숫자 캐시)
- 장점: 의존성 추가 없음, 구현 빠름
- 단점: 데이터가 커지면 JSON 직렬화/역직렬화 비용 증가

권장: 캐시 크기를 제한하기 위해
- “최근 N개월(예: 12개월)”만 저장
- 계정별로 저장 키 분리


### 단계 2: 로컬 DB(sqflite/isar/hive 등)
- 장점: 큰 데이터에 유리, 쿼리/인덱싱 가능
- 단점: 도입 비용

> 이 문서는 단계 1을 기준으로 설계하되, 스키마는 DB로 옮겨도 그대로 유지 가능하게 작성한다.

---

## 스키마(숫자 중심)
### A) 월·소스별 Summary
키(개념): `(accountName, yearMonth, sourceType)`

값:
- `countTotal: int`
- `amountTotalAbs: double`
- `updatedAt: int` (epoch ms)

예시(JSON)
```json
{
  "schema": "monthly_stats_v1",
  "account": "AccountA",
  "months": {
    "2025-12": {
      "tx_memo": {"countTotal": 120, "amountTotalAbs": 850000.0, "updatedAt": 1766790000000},
      "quick_input": {"countTotal": 30, "amountTotalAbs": 95000.0, "updatedAt": 1766790000000}
    },
    "2025-11": {
      "tx_memo": {"countTotal": 98, "amountTotalAbs": 740000.0, "updatedAt": 1764100000000}
    }
  }
}
```


### B) (선택) 월·소스·카테고리별 Summary
키(개념): `(accountName, yearMonth, sourceType, mainCategory)`

값:
- `count: int`
- `amountAbs: double`

> 카테고리 그래프가 필요할 때만 저장한다. 필요 없으면 저장량을 아낄 수 있다.

---

## “메모를 숫자로 변환” 정의 (TODO 4)
‘메모’는 문자열 자체를 저장하지 않고, 아래 형태로 **통계용 숫자**만 남긴다.

1) **빈 메모 제외**
- `memo.trim().isEmpty`면 통계 제외(정책).

2) **카운트는 항상 +1**
- 소스별로 메모 이벤트가 1건 발생하면 `countTotal += 1`.

3) **금액 합계는 절대값 기준**
- 지출/환불/이체 등 타입 차이는 화면 정책에 따라 다르지만,
  입력 통계(메모 통계)의 목적이 “규모(영향)”라면 `abs(amount)` 합산이 일관성이 좋다.

4) (선택) **정규화된 메모 키를 쓰지 않는다(1차)**
- 1차 목표가 “텍스트 저장 최소화”이므로, 메모 문자열을 정규화하여 보관하는 단계는 뒤로 미룬다.

> 즉, TODO 4의 “메모를 숫자변환”은 곧 `count`/`amount`로 축약하는 것을 뜻한다.

---

## 포함할 소스(초안)
1차는 이미 코드가 있는 범위를 우선한다.
- 거래 기반 메모: `Transaction.memo` (지출 중심)
- 간편 지출(1줄): `QuickSimpleExpenseInputHistoryService` (최근 6개월 화면에서 사용 중)

2차 확장(추후)
- 장바구니/일괄입력 메모
- 수입 메모
- 자산 메모
- ROOT 메모

---

## 1년 기록량 계산(숫자 중심)
### 행(row) 기준
- 1년 행 수 = `12 × (계정 수) × (sourceType 수) × (집계 종류 수)`

가벼운 요약만 저장할 때(추천)
- 집계 종류 수: 보통 1 (Summary)
- 예: 계정 5개, sourceType 8개
  - 행 수 = `12×5×8 = 480`행/년

### 저장 용량(대략)
- 숫자만: 행당 수십 바이트~수백 바이트 수준(저장소 포맷에 따라 달라짐)
- SharedPreferences JSON은 key 문자열 오버헤드가 커서, **행 수보다 키 길이**가 용량을 좌우한다.

권장 정책
- `최근 12개월만 유지` (또는 `최근 18개월`)
- 오래된 월은 삭제(또는 내보내기 후 삭제)

---

## 정확도/확장성 트레이드오프
- 이 설계(숫자 중심)는 “그래프/요약 텍스트”에는 매우 적합.
- 하지만 “메모 TOP 10”처럼 텍스트 기반 랭킹을 정확히 하려면
  - (a) 원본 스캔(최근 1500건 제한 등)을 유지하거나
  - (b) 별도의 memoKey 히스토그램 저장(용량 증가)을 추가해야 한다.

---

## 구현 체크리스트(문서용)
- [ ] `MonthlyStatsCacheService`(가칭): 저장/로드/삭제(최근 N개월 유지)
- [ ] `MemoEventBuilder`(가칭): 각 소스에서 월별 이벤트 추출
- [ ] `MonthlyAggregator`(가칭): 이벤트→Summary 집계
- [ ] 트리거 정의: 거래/입력 데이터 변경 시 해당 월 재빌드
- [ ] 화면 적용: 통계 화면은 원본 스캔 대신 월 Summary를 조회

---

## 오픈 질문(결정 필요)
1) ROOT 계정 집계는 “전체 계정 합산”으로 저장할지, 계정별만 저장할지?
2) 금액 합계는 절대값/부호 포함 중 무엇을 기본으로 할지?
3) sourceType 목록(최초 MVP): 어떤 소스를 1차에 포함할지?
4) 캐시 보관 기간: 최근 12개월 vs 24개월?
